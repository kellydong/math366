#This code normalizes a vector, called x, by dividing x 
# by its length. Because of round-off error the code will 
# treat x as the zero vector if its length is smaller than 10^(-6).
# If the vector is "too small" then it is treated as the zero vector
# and the code returns the empty vector NULL

#
nrm = function(x){
  # round off error: for never ending num computer takes only a finite number of places 
  # so 2-(sqrt(2))^2 = 0.00001 not 0
  
  # running into a zero vector
  if( sum(x*x) < 1e-6 ){
    NULL
  }
  else{
    x/sqrt(sum(x^2))# x/length of vector
  }
}
# Ex: x=c(1,2,3)
# nrm(x) = (1/sqrt(14), 2/sqrt(14), 3/sqrt(14))


#This code projects a vector x onto the cols of a matrix A. It is assumed
# that the cols of A are orthonormal. Otherwise the calculation will still 
# run but it will return an answer which is wrong. 

# x is a vector in R^d
# A this is a dxn matrix where the columns are orthonormal
proj = function(x,A){
  n = ncol(A)
  coef = rep(NA,n)
  for(i in 1:n){
    coef[i] = sum(x*A[,i])
  }
  answer = rep(0,n)
  for(i in 1:n){
    answer = answer + coef[i]*A[,i] 
  }
  answer
}


#This is the Gram-Schmidt algorithm. You start with a matrix A. The algorithm
# applies the GS-algorithm to the subspace generated by the cols of A. The 
# resulting matrix in the end might be smaller. The number of cols is the 
# dim. of the subspace. The cols of the output matrix will be orthonormal


# A = matrix of input vectors, the matrix use to generate the span
gram.schmidt = function(A){
  n = ncol(A)
  # normalized the first column in A, assuming that the very first column is not a zero vector
  # Call this the column matrix so put it in matrix function and set it to Q
  Q = matrix( nrm(A[,1]) )
  # will get a technical vector when the number of column is 1, assuming n is at least 2
  # 
  for(i in 2:n){
    # attaching the normalize vector to the Q matrix (initially the single column matrix)
    Q = cbind( Q , nrm( A[,i] - proj(A[,i],Q) ) )
  }
  Q
  # t(Q) %*% Q # Checking to see if the columns are orthonormal
}

#Ex
A = cbind(1:4,5:8,9:12)
# interested in the span(A) the dimension of the 3 vector
gram.schmidt(A) # result is a 4x2 so dim(2) = 2 not 3, since one of them is dependent

t(Q) %*% Q # should get an identity matrix

# can try to improve the code for so that it won't break if the first column is 0 for Q
